#### 阶段一：物理世界与预测核心（Day 1 - Day 5）
**目标：让计算机学会“怕死”（实现非对称预测）。**

**Day 1: 理解并实现 LinEx Loss**
*   **核心概念：** 理解为什么 MSE 是对称的（早修晚修惩罚一样），而 LinEx 是非对称的（晚修惩罚指数爆炸）。
*   **今日任务：**
    1.  打开 Python，导入 NumPy 和 Matplotlib。
    2.  定义函数 `linex_loss(y_true, y_pred, a)`。公式：`Loss = exp(a * (y_pred - y_true)) - a * (y_pred - y_true) - 1`。（注意：这里通常定义 error = pred - true，如果 error < 0 代表低估/保守，如果 a>0 且 error > 0 代表高估/危险，具体符号需根据你想惩罚哪一边来定，假设我们要惩罚高估 RUL）。
    3.  生成一组误差值从 -5 到 5，画出 Loss 曲线。
    4.  **验收标准：** 看到曲线一边平缓，一边陡峭。

**Day 2: 生成“像真的”退化数据**
*   **核心概念：** 异方差性（Heteroscedasticity）。机器越老，预测越不准。
*   **今日任务：**
    1.  写一个生成器 `generate_data(n_samples=100)`。
    2.  **关键逻辑：** 不要用直线加噪声。用累加噪声（随机游走）。
        *   `health[t] = health[t-1] - degradation_rate + noise`。
        *   让 `noise` 的方差随着 `t` 稍微变大一点点（模拟老化带来的不稳定性）。
    3.  画出 5 条退化曲线。
    4.  **验收标准：** 曲线看起来像股票走势图，且尾部比头部更“抖”。

**Day 3: 搭建 Baseline (MSE) 模型**
*   **核心概念：** 建立对照组（风险中性模型）。
*   **今日任务：**
    1.  使用 PyTorch 搭建一个最简单的 Bi-LSTM（3层全连接层）。
    2.  输入：当前的传感器读数（Health Index）。输出：RUL。
    3.  使用 `nn.MSELoss` 训练模型。
    4.  **验收标准：** 在测试集画图，预测线应该穿过真实数据点的**中间**。

**Day 4: 训练 Risk-Aware (LinEx) 模型**
*   **核心概念：** 注入风险偏好。
*   **今日任务：**
    1.  复用 Day 3 的网络结构。
    2.  将 Loss 函数替换为 Day 1 写的 `linex_loss`（封装成 PyTorch Module）。
    3.  设定参数 $a=0.1$（或者根据你的数据量级调整），重新训练。
    4.  **验收标准：** 在同一张图上画出 MSE 和 LinEx 的预测线。LinEx 的线应该明显跑在真实值的**下方**（低估寿命，保守）。

**Day 5: 验证“方差敏感性”**
*   **核心概念：** 验证理论——不确定性越大，偏移越大。
*   **今日任务：**
    1.  计算测试集每个点的 `Variance`（可以用滑窗方差估计）和 `Bias` (预测值 - 真实值)。
    2.  画散点图：X轴是方差，Y轴是 Bias。
    3.  **验收标准：** 应该看到一个趋势：X 越大（越不确定），Y 越负（越保守）。这是论文里最喜欢展示的图。

---

#### 阶段二：受限决策与模拟（Day 6 - Day 10）
**目标：模拟“抢维修资源”的游戏（Fleet Maintenance）。**

**Day 6: 定义 FSM 游戏规则（成本与约束）**
*   **核心概念：** 资源是有限的，这是 FSM 的核心。
*   **今日任务：**
    1.  定义成本字典：
        *   `C_preventive` (提前修) = 10。
        *   `C_failure` (坏了修) = 100。
        *   `C_waste` (每浪费1单位寿命) = 1。
    2.  **定义约束（关键纠正）：** 设定 `Capacity = K`。即每天维修厂只能修 K 台机器。假设你有 20 台机器，K=2。
    3.  写一个 `calculate_cost` 函数。

**Day 7: 编写“贪心”调度策略**
*   **核心概念：** 启发式算法。
*   **今日任务：**
    1.  编写函数 `scheduler(predicted_ruls, capacity)`。
    2.  逻辑：
        *   对所有机器的预测 RUL 从小到大排序。
        *   选出前 `capacity` 个 RUL 最小的机器。
        *   如果这些机器的 RUL 小于某个安全阈值，就修；否则不修。
    3.  **验收标准：** 输入一组 RUL，输出一个 0/1 列表（修谁）。


**Day 8: 编写“滚动时域”模拟器**
*   **核心概念：** 时间推演。
*   **今日任务：**
    1.  写主循环 `for day in range(100):`。
    2.  **Step 1:** 机器老化（真实 RUL - 1）。如果 RUL <= 0，状态变“故障”。
    3.  **Step 2:** 模型预测当前 RUL。
    4.  **Step 3:** 调用 Day 7 的调度器决定修谁。
    5.  **Step 4:** 结算当日成本（故障惩罚 + 维修费 + 浪费费）。维修后的机器 RUL 重置。
    6.  **验收标准：** 打印日志，能看到机器“运行->维修->重置”的循环。

**Day 9: 跑通 MSE 模型模拟**
*   **核心概念：** 基准测试。
*   **今日任务：**
    1.  把 Day 3 的 MSE 模型放入模拟器。
    2.  跑 1000 天。
    3.  记录：总故障次数、总维修次数、总成本。
    4.  **预期：** 可能会因为预测不准（高估寿命），导致排队修机器时，有些机器还没排到就坏了（故障次数高）。

**Day 10: 跑通 LinEx 模型模拟**
*   **核心概念：** 验证收益。
*   **今日任务：**
    1.  把 Day 4 的 LinEx 模型放入模拟器。
    2.  跑 1000 天。
    3.  记录数据。
    4.  **预期对比：** LinEx 模型因为预测保守，会更早地把机器送去排队。虽然可能造成一些浪费，但应该能显著减少“插队不及导致的故障”。

---

#### 阶段三：分析与升华（Day 11 - Day 14）
**目标：完成论文级图表。**

**Day 11: 参数扫描（寻找 Golden $a$）**
*   **核心概念：** 权衡（Trade-off）。
*   **今日任务：**
    1.  写个循环，让 $a$ 从 0.0 到 2.0 变化。
    2.  对每个 $a$，跑一遍 Day 10 的模拟。
    3.  收集总成本。

**Day 12: 绘制“成本微笑曲线”**
*   **核心概念：** 凸优化直觉。
*   **今日任务：**
    1.  X轴是 $a$，Y轴是总成本。
    2.  **验收标准：** 应该是一个 U 型曲线。
        *   $a$ 太小（MSE）：故障多，贵。
        *   $a$ 太大（过分保守）：大家都在排队修，资源挤兑，导致真正紧急的修不上，依然会坏，且浪费巨大，贵。
        *   中间有个最低点。

**Day 13: 瓶颈分析**
*   **核心概念：** 约束的影响。
*   **今日任务：**
    1.  改变 Day 6 的 `Capacity`（比如从 2 改成 5）。
    2.  重画 Day 12 的曲线。
    3.  **观察：** 资源越充足，LinEx 的“过度保守”带来的负面影响越小（反正修得过来）。

**Day 14: 整理 Toy Model 报告**
*   **今日任务：**
    1.  整理代码结构。
    2.  将 Day 2（数据）、Day 4（预测对比）、Day 12（成本曲线）的三张图放在一起。
    3.  写一段结论。
