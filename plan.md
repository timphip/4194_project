#### 阶段一：物理世界与预测核心（Day 1 – Day 5）
**目标：让计算机学会"怕死"（实现非对称预测）。**

**Day 1: 理解并实现 LinEx Loss**
*   **核心概念：** 理解为什么 MSE 是对称的（早修晚修惩罚一样），而 LinEx 是非对称的（晚修惩罚指数爆炸）。
*   **今日任务：**
    1.  打开 Python，导入 NumPy 和 Matplotlib。
    2.  定义函数 `linex_loss(y_true, y_pred, a)`。公式：`Loss = exp(a * (y_pred - y_true)) - a * (y_pred - y_true) - 1`。（注意：这里通常定义 error = pred − true，如果 error < 0 代表低估/保守，如果 a>0 且 error > 0 代表高估/危险，具体符号需根据你想惩罚哪一边来定，假设我们要惩罚高估 RUL）。
    3.  生成一组误差值从 −5 到 5，画出 Loss 曲线。
    4.  **验收标准：** 看到曲线一边平缓，一边陡峭。

**Day 2: 生成"像真的"退化数据**
*   **核心概念：** 异方差性（Heteroscedasticity）。机器越老，预测越不准。
*   **今日任务：**
    1.  写一个生成器 `generate_data(n_samples=100)`。
    2.  **关键逻辑：** 不要用直线加噪声。用累加噪声（随机游走）。
        *   `health[t] = health[t-1] - degradation_rate + noise`。
        *   让 `noise` 的方差随着 `t` 稍微变大一点点（模拟老化带来的不稳定性）。
    3.  画出 5 条退化曲线。
    4.  **验收标准：** 曲线看起来像股票走势图，且尾部比头部更"抖"。

**Day 3: 搭建 Baseline (MSE) 模型**
*   **核心概念：** 建立对照组（风险中性模型）。
*   **今日任务：**
    1.  使用 PyTorch 搭建一个最简单的 Bi-LSTM（3 层全连接层）。
    2.  输入：当前的传感器读数（Health Index）。输出：RUL。
    3.  使用 `nn.MSELoss` 训练模型。
    4.  **验收标准：** 在测试集画图，预测线应该穿过真实数据点的**中间**。

**Day 4: 训练 Risk-Aware (LinEx) 模型**
*   **核心概念：** 注入风险偏好。
*   **今日任务：**
    1.  复用 Day 3 的网络结构。
    2.  将 Loss 函数替换为 Day 1 写的 `linex_loss`（封装成 PyTorch Module）。
    3.  设定参数 $a=0.1$（或者根据你的数据量级调整），重新训练。
    4.  **验收标准：** 在同一张图上画出 MSE 和 LinEx 的预测线。LinEx 的线应该明显跑在真实值的**下方**（低估寿命，保守）。

**Day 5: 验证"方差敏感性"**
*   **核心概念：** 验证理论——不确定性越大，偏移越大。
*   **今日任务：**
    1.  计算测试集每个点的 `Variance`（可以用滑窗方差估计）和 `Bias` (预测值 − 真实值)。
    2.  画散点图：X 轴是方差，Y 轴是 Bias。
    3.  **验收标准：** 应该看到一个趋势：X 越大（越不确定），Y 越负（越保守）。这是论文里最喜欢展示的图。

---

#### 阶段二：受限决策与模拟（Day 6 – Day 10）
**目标：模拟"抢维修资源"的游戏（Fleet Maintenance），并用 HiGHS 求解最优调度。**

**Day 6: 定义 FSM 游戏规则（成本与约束）**
*   **核心概念：** 资源是有限的，这是 FSM 的核心。
*   **今日任务：**
    1.  定义成本字典：
        *   `C_preventive` (提前修) = 10。
        *   `C_failure` (坏了修) = 100。
        *   `C_waste` (每浪费 1 单位寿命) = 1。
    2.  **定义约束（关键纠正）：** 设定 `Capacity = K`。即每天维修厂只能修 K 台机器。假设你有 20 台机器，K=2。
    3.  写一个 `calculate_cost` 函数。

**Day 7: 编写 HiGHS MILP 最优调度策略**
*   **核心概念：** 混合整数线性规划（MILP）精确求解，替代启发式贪心。
*   **为什么用 HiGHS 而不是贪心：**
    *   贪心只按 RUL 排序取前 K 个，**忽略了维修成本与故障风险之间的权衡**——可能选了一台 RUL=14 的机器（修了浪费很多），而放过了一台 RUL=2 的（其实净收益更大）。
    *   MILP 显式最小化「维修成本 − 故障风险」的总净成本，在容量约束下给出**数学上最优**的维修决策。
*   **今日任务：**
    1.  安装 HiGHS 求解器：`pip install highspy`。
    2.  编写函数 `highs_scheduler(predicted_ruls, capacity, safety_threshold, config)`。
    3.  **建模逻辑（二元整数规划）：**
        *   **决策变量：** $x_i \in \{0, 1\}$，第 $i$ 台机器是否维修。
        *   **目标函数：** 最小化

            $$\min \sum_{i=1}^{N} x_i \cdot \bigl(m_i - f_i\bigr)$$

            其中：
            *   $m_i = C_{\text{preventive}} + C_{\text{waste}} \times \hat{r}_i$ —— 维修第 $i$ 台机器的成本（预防 + 浪费剩余寿命）。
            *   $f_i = C_{\text{failure}} \times \max\!\bigl(0,\ 1 - \hat{r}_i / T\bigr)$ —— 不维修时的预期故障风险成本（$\hat{r}_i$ 越小，风险越高）。
            *   系数 $(m_i - f_i) < 0$ 表示「修比不修划算」，求解器会倾向于令 $x_i = 1$。
        *   **约束：** $\displaystyle\sum_{i=1}^{N} x_i \leq K$（每天最多修 $K$ 台）。
    4.  调用 `h = highspy.Highs()`，添加变量、约束、目标，执行 `h.run()`，读取解。
    5.  **验收标准：** 输入一组 RUL，输出一个 0/1 列表（修谁）。结果应比贪心更优或至少相同——可以同时运行贪心与 HiGHS 做直观对比。

**Day 8: 编写"滚动时域"模拟器**
*   **核心概念：** 时间推演。
*   **今日任务：**
    1.  写主循环 `for day in range(100):`。
    2.  **Step 1:** 机器老化（真实 RUL − 1）。如果 RUL ≤ 0，状态变「故障」。
    3.  **Step 2:** 模型预测当前 RUL。
    4.  **Step 3:** 调用 Day 7 的 HiGHS 调度器决定修谁（求解 MILP）。
    5.  **Step 4:** 结算当日成本（故障惩罚 + 维修费 + 浪费费）。维修后的机器 RUL 重置。
    6.  **验收标准：** 打印日志，能看到机器「运行→维修→重置」的循环。

**Day 9: 跑通 MSE 模型模拟**
*   **核心概念：** 基准测试。
*   **今日任务：**
    1.  把 Day 3 的 MSE 模型放入模拟器（调度器已经是 HiGHS）。
    2.  跑 1000 天。
    3.  记录：总故障次数、总维修次数、总成本。
    4.  **预期：** 即使调度器已是最优，MSE 预测本身的对称误差仍会导致高估寿命 → 有些机器还没排到就坏了（故障次数偏高）。

**Day 10: 跑通 LinEx 模型模拟**
*   **核心概念：** 验证收益。
*   **今日任务：**
    1.  把 Day 4 的 LinEx 模型放入模拟器（同样使用 HiGHS 调度）。
    2.  跑 1000 天。
    3.  记录数据。
    4.  **预期对比：** LinEx 模型预测保守 → 更早报告低 RUL → HiGHS 有更准确的成本系数做决策 → 故障显著减少。虽然可能造成一些预防性维修浪费，但总成本应低于 MSE。

---

#### 阶段三：分析与升华（Day 11 – Day 14）
**目标：完成论文级图表。**

**Day 11: 参数扫描（寻找 Golden $a$）**
*   **核心概念：** 权衡（Trade-off）。
*   **今日任务：**
    1.  写个循环，让 $a$ 从 0.0 到 2.0 变化。
    2.  对每个 $a$，跑一遍 Day 10 的模拟（HiGHS 调度 + LinEx 预测）。
    3.  收集总成本。

**Day 12: 绘制"成本微笑曲线"**
*   **核心概念：** 凸优化直觉。
*   **今日任务：**
    1.  X 轴是 $a$，Y 轴是总成本。
    2.  **验收标准：** 应该是一个 U 型曲线。
        *   $a$ 太小（MSE）：故障多，贵。
        *   $a$ 太大（过分保守）：大家都在排队修，资源挤兑，导致真正紧急的修不上，依然会坏，且浪费巨大，贵。
        *   中间有个最低点。

**Day 13: 瓶颈分析**
*   **核心概念：** 约束的影响。
*   **今日任务：**
    1.  改变 Day 6 的 `Capacity`（比如从 2 改成 5）。
    2.  重画 Day 12 的曲线。
    3.  **观察：** 资源越充足，LinEx 的"过度保守"带来的负面影响越小（反正修得过来）。同时 HiGHS 最优调度的优势在紧资源 (K 小) 时尤为突出。

**Day 14: 整理 Toy Model 报告**
*   **今日任务：**
    1.  整理代码结构。
    2.  将 Day 2（数据）、Day 4（预测对比）、Day 12（成本曲线）的三张图放在一起。
    3.  写一段结论——特别说明：
        *   为什么选择 HiGHS MILP 替代贪心（精确 vs. 启发式）。
        *   LinEx + HiGHS 组合如何在预测端和决策端同时注入风险意识。
